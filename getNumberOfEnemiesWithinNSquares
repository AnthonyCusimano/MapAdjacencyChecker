const char MapAdjacencyChecker::getNumberOfEnemiesWithinNSquares(GenericCharacter const* _center, BattleChapter *_theChapter, char const _centerTeam, char const _radius) {

	char T_return = 0;

	char xOffset = 0;
	char yOffset = _radius;

	//if center is under the player's control
	if (_centerTeam == 0) {

		//moving down y and expanding along X
		//as we go down on y, closer to 0, the xOffset should grow
		for (char i = yOffset; i >= -yOffset; --i) {
			//this looks terrible
			for (char j = xOffset; j >= -xOffset; --j) {

				//if (_center->getMyPosition().x + j >= 0 && _center->getMyPosition().y + i >= 0)
				if (_center->getMyPosition().x + j >= 0 && _center->getMyPosition().y + i >= 0 && _center->getMyPosition().x + j < ::MAP_ONE_LENGTH && _center->getMyPosition().y + i < ::MAP_ONE_HEIGHT) {

					//visual aid to see what squares this method is checking
					_theChapter->myGrid->theGrid[(int)_center->getMyPosition().x + j][(int)_center->getMyPosition().y + i].AssignType(SQUARE_TYPE_DESERT);

					//checking to see if a square is occupied for an enemy
					if (_theChapter->myGrid->theGrid[(int)_center->getMyPosition().x + j][(int)_center->getMyPosition().y + i].isEnemyOccupied) {

						//for each enemy...
						//int _index char i?
						for (int _index = 0; _index < _theChapter->myArmy.size(); ++_index) {

							//std::cout << (int)_theChapter->myArmy[i]->getMyPosition().x << ' ' << (int)_theChapter->myArmy[i]->getMyPosition().y << '\n';

							if (_theChapter->myGrid->theGrid[(int)_center->getMyPosition().x + j][(int)_center->getMyPosition().y + i].myPosition == _center->getMyPosition()) {

								//std::cout << (int)_theChapter->myArmy[i]->getMyPosition().x << ' ' << (int)_theChapter->myArmy[i]->getMyPosition().y << '\n';

								++T_return;

								break;

							}							

						}

					}

				}

			}

			//i checks where we are along Y throughout this process
			if (i > 0)
				++xOffset;

			else
				--xOffset;
		}

	}

	//if center is under the enemy's control
	else if (_centerTeam == 1) {



	}

	//if center is a neutral unit
	else {



	}

	return T_return;

}
