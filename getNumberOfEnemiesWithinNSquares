const char MapAdjacencyChecker::getNumberOfEnemiesWithinNSquares(GenericCharacter const* _center, BattleChapter *_theChapter, char const _centerTeam, char const _radius) {

	char T_return = 0;

	//GridPosition T_helper;

	char xOffset = 0;
	char yOffset = _radius;

	//if center is under the player's control
	if (_centerTeam == 0) {

		//moving down y and expanding along X
		//as we go down on y, closer to 0, the xOffset should grow
		for (char i = yOffset; i >= -yOffset; --i) {
			//this looks terrible
			for (char j = xOffset; j >= -xOffset; --j) {

				//if (_center->getMyPosition().x + j >= 0 && _center->getMyPosition().y + i >= 0)
				if (_center->getMyPosition().x + j >= 0 && _center->getMyPosition().y + i >= 0 && _center->getMyPosition().x + j < ::MAP_ONE_LENGTH && _center->getMyPosition().y + i < ::MAP_ONE_HEIGHT) {

					//visual aid to see what squares this method is checking
					_theChapter->myGrid->theGrid[(int)_center->getMyPosition().x + j][(int)_center->getMyPosition().y + i].AssignType(SQUARE_TYPE_DESERT);

					//checking to see if a square is occupied for an enemy
					if (_theChapter->myGrid->theGrid[(int)_center->getMyPosition().x + j][(int)_center->getMyPosition().y + i].isEnemyOccupied) {

						std::cout << "You should see this message once!\n";

						//for each enemy...
						for (int i = 0; i < _theChapter->myArmy.size(); ++i) {

							/*std::cout << _theChapter->myArmy.size() << '\n';
							std::cout << "Checking EnemyGuy's position\n";*/

							if (_theChapter->myGrid->theGrid[(int)_center->getMyPosition().x + j][(int)_center->getMyPosition().y + i].myPosition == _center->getMyPosition()) {

								++T_return;

								break;

							}							

						}

					}

				}

			}

			//i checks where we are along Y throughout this process
			if (i > 0)
				++xOffset;

			else/* if (0 > i)*/
				--xOffset;
		}

	}

	//if center is under the enemy's control
	else if (_centerTeam == 1) {



	}

	//if center is a neutral unit
	else {



	}

	return T_return;

}
